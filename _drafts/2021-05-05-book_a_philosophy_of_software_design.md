---
layout: blog
title: "Read Book: A Philosophy of Software Design"
---

[A Philosophy of Software Design](https://www.amazon.co.jp/dp/B07N1XLQ7D/ref=cm_sw_em_r_mt_dp_JMCWYZ63EQGY1Q6BTGST)

よいソフトウェアデザイン、コードとは何か、ソフトウェア開発で常に考えるテーマです。
経験を通じて直観的な感覚は養われていくのですが、この本はその点を言語化し、体系化を試みており、自分の知見の整理に役立ちました。
実体験を踏まえ、印象に残った点をまとめます。
<!--end_excerpt-->

この本のテーマは大まかに2点で、1) ソフトウェアの複雑さとは何か、なぜよいデザインが重要かについてと、
2) デザインを向上する技法についてです。
2章が前者で、3章以降は後者の説明に充てられています。自分の感想もこの2点に分けてまとめます。

# ソフトウェアの複雑さについて
著者はソフトウェアの複雑さを、ソフトウェアの構成要素のうち、システムの理解及び変更修正の難度を上げる全ての要因と定義しています。
これは個人的にも納得感のある定義でした。ソフトウェアエンジニアの役割とは、実世界の変わりゆく要求・課題に対して、
計算機を活用することで解決に導くことであると考えるので、システムの変化への適応性は本質的に必要とされる要素と思います。

また、より多くの時間開発者の目に触れる箇所ほど、複雑さを増す弊害が大きいと述べられています。
この点は、特に仕事としてチームで開発していると強く感じるところです。
コードを注意深く読まないと挙動が理解できないソフトウェアは、チームの生産性に悪影響を与えます。
より多くの開発者の目に触れるであろうソフトウェアほど、よいデザインを作ることのレバレッジが大きくなります。
さらに、後ろの章でも触れられていますが、ソフトウェアデザインは開発者にとっての利便性より、
コードを読み、利用する人にとっての複雑さを重視するべきというのも大事なポイントです。
一般的に開発期間と運用期間では、後者が大半を占めるわけですし、その間多くの人がデザインを目にする場合、
各個人が理解にかかる時間を短くする方が、オリジナルの開発者の時間を節約するより効果が大きいです。

複雑度が高いシステムの弊害として、以下の3点が挙げられています。
- Change amplification
- Cognitive load
- Unknown unknowns

コードを読んだり変更修正する際にこうした影響を受けるわけですが、最初の2つはまだましで、コードの理解や変更に
余計な時間がかかることが主なデメリットと思います。（それ自体もバグを生む遠因となり得るので決してよくはありませんが。）
一方で、"Unknown unknowns"については、理解を妨げるだけでなく、変更の影響範囲が特定できなくなるため、
容易に破壊的な変更を埋め込んでしまうようになります。コードに触れる人が想定できないような挙動は、可能であれば排除し、
避けられない場合もドキュメント等で十分な注意喚起をするべきです。

# ソフトウェアデザインを向上する技法について
3章以降は、よいデザインを作り上げるための技法の、トピック別での解説になっています。
数が多いので、ここでは自分にとって発見だった箇所のみ取り上げます。

## Working Code Isn't Enough
本の中では、Strategic (戦略的な) ProgrammingとTactical (急場しのぎの) Programmingという対比で論じられていますが、
スピード感を求められる現場では、往々にして多少の複雑さを許容して、短い期間での開発を要求されることがあります。
ビジネスの都合上ある程度は避けられないのですが、一旦ソフトウェアに入り込んだ複雑さは大体想定よりも早い段階で悪影響を及ぼします。
個人的にも、1週間コードから離れていたら、戻ってきたとき意図が分からなくなっていることは非常によくあります。
急場しのぎのコードを書かざるを得ない場合は、リファクタリングする期間を決め、さらに可能な限りオリジナルの開発者が実施することを
確約したうえで進めるべきというのが自分の意見です。いつか直そうくらいの感覚でいると直す日はやってこないです。
最初のコードを書いた記憶が鮮明なうちに直した方が効率も良いと思います。

安全にリファクタリングするための原則として、機能開発とリファクタリングを同時に実施するべきではないという意見がありますが、
個人的には外部仕様に影響がない範囲で、かつレビューが大変になりすぎない程度であれば混ぜてしまっても良いと考えています。
リファクタリングを遅らせるほど、それまでに増えたコードもリファクタリングの対象になり変更量が大きくなりやすいです。
インクリメンタルに小さなリファクタリングを実施する方が、見通しよくコードが書けると思います。
自分のこれまでの仕事の中で、既存サービスのマイグレーションや、巨大化したサービスの分離などといった作業がありましたが、
こうした作業でも、単にマイグレーション、分離をするよりは、今のシステムに適した形のリファクタリングを含めるのが良いと考えています。